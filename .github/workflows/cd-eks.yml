# =============================================================================
# Medic CD Pipeline - Deploy to EKS
# =============================================================================
# Triggers after successful CI build on main branch.
# Deploys the new Docker image to EKS via Terraform/Helm.
#
# Flow:
#   1. CI workflow builds and pushes image to ECR
#   2. This workflow triggers on CI success
#   3. Updates image tag in Terraform and applies
#
# Required Secrets:
#   - AWS_ACCESS_KEY_ID: AWS access key
#   - AWS_SECRET_ACCESS_KEY: AWS secret key
#
# Required Variables:
#   - TF_STATE_BUCKET: S3 bucket for Terraform state
#   - TF_STATE_KEY: Key prefix for state file
#   - TF_STATE_DYNAMODB_TABLE: DynamoDB table for state locking
# =============================================================================

name: CD - Deploy to EKS

on:
  # Trigger after CI workflow completes successfully
  workflow_run:
    workflows: ["Build and Test"]
    types: [completed]
    branches: [main]

  # Manual deployment with optional image tag override
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        type: choice
        options:
          - dev
          - prod
        default: dev
      image_tag:
        description: "Image tag to deploy (leave empty for latest commit SHA)"
        required: false
        type: string

# Prevent concurrent deployments to the same environment
concurrency:
  group: deploy-${{ github.event.inputs.environment || 'dev' }}
  cancel-in-progress: false

env:
  AWS_REGION: us-east-2
  TERRAFORM_VERSION: "1.7.0"

jobs:
  # ---------------------------------------------------------------------------
  # Determine deployment parameters
  # ---------------------------------------------------------------------------
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    # Only run if CI succeeded or manual trigger
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.event.workflow_run.conclusion == 'success'

    outputs:
      image_tag: ${{ steps.tag.outputs.image_tag }}
      environment: ${{ steps.env.outputs.environment }}
      should_deploy: ${{ steps.check.outputs.should_deploy }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # For workflow_run, checkout the commit that triggered CI
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Determine environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            # Auto-deploy to dev on CI success
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi

      - name: Determine image tag
        id: tag
        run: |
          if [[ -n "${{ github.event.inputs.image_tag }}" ]]; then
            # Manual override
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          elif [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            # Use commit SHA from CI trigger
            IMAGE_TAG=$(echo "${{ github.event.workflow_run.head_sha }}" | cut -c1-7)
          else
            # Fallback to current commit
            IMAGE_TAG=$(git rev-parse --short=7 HEAD)
          fi
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Image tag: ${IMAGE_TAG}"

      - name: Check if image exists
        id: check
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          IMAGE_TAG="${{ steps.tag.outputs.image_tag }}"

          # Check if image exists in ECR
          if aws ecr describe-images \
              --repository-name medic \
              --image-ids imageTag="${IMAGE_TAG}" \
              --region us-east-1 > /dev/null 2>&1; then
            echo "âœ… Image medic:${IMAGE_TAG} found in ECR"
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Image medic:${IMAGE_TAG} not found in ECR"
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

  # ---------------------------------------------------------------------------
  # Deploy to EKS via Terraform
  # ---------------------------------------------------------------------------
  deploy:
    name: Deploy to ${{ needs.prepare.outputs.environment }}
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.should_deploy == 'true'

    # Use GitHub Environments for approval (prod requires manual approval)
    environment:
      name: ${{ needs.prepare.outputs.environment }}

    env:
      TF_ENVIRONMENT: ${{ needs.prepare.outputs.environment }}
      TF_VAR_image_tag: ${{ needs.prepare.outputs.image_tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: terraform/environments/${{ env.TF_ENVIRONMENT }}
        run: |
          terraform init \
            -backend-config="bucket=${{ vars.TF_STATE_BUCKET }}" \
            -backend-config="key=${{ vars.TF_STATE_KEY }}/${{ env.TF_ENVIRONMENT }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ vars.TF_STATE_DYNAMODB_TABLE }}" \
            -backend-config="encrypt=true"

      - name: Terraform Plan
        id: plan
        working-directory: terraform/environments/${{ env.TF_ENVIRONMENT }}
        run: |
          echo "ðŸ“‹ Planning deployment of medic:${{ needs.prepare.outputs.image_tag }}"

          terraform plan \
            -var="image_tag=${{ needs.prepare.outputs.image_tag }}" \
            -out=tfplan \
            -no-color | tee plan-output.txt

          # Check if there are changes
          if grep -q "No changes" plan-output.txt; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi

      - name: Terraform Apply
        if: steps.plan.outputs.has_changes == 'true'
        working-directory: terraform/environments/${{ env.TF_ENVIRONMENT }}
        run: |
          echo "ðŸš€ Deploying medic:${{ needs.prepare.outputs.image_tag }} to ${{ env.TF_ENVIRONMENT }}"
          terraform apply -auto-approve tfplan

      - name: Verify Deployment
        run: |
          echo "â³ Waiting for deployment to stabilize..."
          sleep 30

          # Configure kubectl (requires EKS cluster access)
          aws eks update-kubeconfig --name o11y-prod --region ${{ env.AWS_REGION }}

          # Check pod status
          echo "ðŸ“Š Pod status:"
          kubectl get pods -n medic -l app.kubernetes.io/name=medic

          # Check if all pods are ready
          READY_PODS=$(kubectl get pods -n medic -l app.kubernetes.io/name=medic \
            -o jsonpath='{.items[*].status.conditions[?(@.type=="Ready")].status}' | tr ' ' '\n' | grep -c True || echo 0)
          TOTAL_PODS=$(kubectl get pods -n medic -l app.kubernetes.io/name=medic --no-headers | wc -l)

          if [[ "$READY_PODS" -eq "$TOTAL_PODS" && "$TOTAL_PODS" -gt 0 ]]; then
            echo "âœ… All $TOTAL_PODS pods are ready"
          else
            echo "âš ï¸ Only $READY_PODS of $TOTAL_PODS pods are ready"
          fi

      - name: Deployment Summary
        run: |
          echo "### âœ… Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** \`${{ env.TF_ENVIRONMENT }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** \`${{ needs.prepare.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** \`${{ github.event.workflow_run.head_sha || github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  # ---------------------------------------------------------------------------
  # Notify on failure
  # ---------------------------------------------------------------------------
  notify-failure:
    name: Notify Failure
    runs-on: ubuntu-latest
    needs: [prepare, deploy]
    if: failure()

    steps:
      - name: Deployment Failed
        run: |
          echo "### âŒ Deployment Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** \`${{ needs.prepare.outputs.environment }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** \`${{ needs.prepare.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Check the workflow logs for details." >> $GITHUB_STEP_SUMMARY
