# Ralph Progress Log
Started: Tue Feb  3 13:50:31 CST 2026

## Codebase Patterns
- Database: PostgreSQL with raw SQL (no ORM, no migration framework like Alembic)
- Tables are in the `medic` schema
- Migrations stored in `/migrations/` directory as numbered SQL files (016 is latest)
- Secrets encryption uses AES-256-GCM with key from MEDIC_SECRETS_KEY env var (base64-encoded 32-byte key)
- Use substitute_all() for variable+secret substitution in playbook steps
- All queries use parameterized queries with `%s` placeholders
- Python type checking via mypy (existing codebase has pre-existing type errors in heartbeat.py, medic.py, pagerduty_client.py)
- Unit tests in tests/unit/, run with `python3 -m pytest tests/unit/ -v`
- Pre-existing test failures in test_monitor.py due to missing `slack_client` module (not related to new code)
- **UI Stack**: Vite 7 + React 19 + TypeScript in ui/ directory
- **UI Quality**: Run `npm run typecheck && npm run lint` before committing UI changes
- **UI Build**: `npm run build` creates production bundle in ui/dist/
---

## 2026-02-03 14:15 CST - US-035
- What was implemented:
  - Created approval_requests table migration (migrations/014_create_approval_requests.sql)
  - Columns: request_id (PK), execution_id (FK unique), requested_at, expires_at, status, decided_by, decided_at
  - Status values: pending, approved, rejected, expired
  - CHECK constraint ensures decided_by/decided_at set appropriately per status
  - Indexes: execution_id, status, pending requests, expires_at, decided_by, decided_at
- Files changed:
  - migrations/014_create_approval_requests.sql (new)
- **Learnings for future iterations:**
  - Migration file numbering: check existing migrations to find next number (was 014)
  - Follow existing pattern for table/column comments
  - CHECK constraints can enforce business logic (e.g., decided_by must be set when status is approved/rejected)
  - Unique constraint on execution_id ensures one approval request per execution
---

## 2026-02-03 14:45 CST - US-036 - Linear Issue: SRE-22
- What was implemented:
  - Created Medic/Core/slack_approval.py module with:
    - ApprovalStatus enum (pending, approved, rejected, expired)
    - ApprovalRequest and ApprovalResult dataclasses
    - Database operations: create/get/update approval_requests records
    - Slack Block Kit message building with interactive buttons
    - send_approval_request(): Sends Slack message with Approve/Decline buttons
    - handle_slack_interaction(): Processes button click callbacks
    - approve_request(): Updates status to approved, resumes playbook execution
    - reject_request(): Updates status to rejected, cancels playbook execution
    - Slack signature verification for webhook security
    - expire_pending_requests(): Handles auto-expiration of timed-out requests
  - Added POST /v2/slack/interactions endpoint in routes.py
- Files changed:
  - Medic/Core/slack_approval.py (new, ~1200 lines)
  - Medic/Core/routes.py (added Slack interactions endpoint)
  - tests/unit/test_slack_approval.py (new, 42 unit tests)
- **Learnings for future iterations:**
  - Slack interactive messages use Block Kit format with specific block types (header, section, actions, context)
  - Slack webhook payloads come as form-urlencoded with a 'payload' JSON field
  - Signature verification uses HMAC-SHA256 with v0:timestamp:body format
  - For button actions, action_id identifies the action and value carries the payload (e.g., execution_id)
  - chat_update can replace interactive buttons with static result after decision
  - Import slack_approval inside route function to avoid circular imports
---

## 2026-02-03 21:00 CST - US-044
- What was implemented:
  - Created medic.secrets table migration (migrations/016_create_secrets.sql)
    - Columns: secret_id (PK), name (unique), encrypted_value (BYTEA), nonce (12 bytes), tag (16 bytes)
    - Name format constraint: [A-Za-z_][A-Za-z0-9_]*
    - Description and created_by optional columns
  - Implemented Medic/Core/secrets.py module with:
    - AES-256-GCM encryption using cryptography library
    - Key from MEDIC_SECRETS_KEY env var (base64-encoded 32-byte key)
    - generate_encryption_key() for generating new keys
    - encrypt_secret()/decrypt_secret() for AES-GCM operations
    - CRUD functions: create_secret(), get_secret(), update_secret(), delete_secret(), list_secrets()
    - get_secret_value() for decrypting at execution time
    - substitute_secrets() for ${secrets.SECRET_NAME} syntax
    - find_secret_references() and validate_secret_references() helpers
  - Updated Medic/Core/playbook_engine.py:
    - Added substitute_all() function to handle both variables and secrets
    - Updated webhook step to use substitute_all() for URL, headers, body
    - Updated script step to use substitute_all() for script content
    - Added error handling for secret substitution failures
  - Added cryptography>=42.0.0 to Medic/requirements.txt
- Files changed:
  - migrations/016_create_secrets.sql (new)
  - Medic/Core/secrets.py (new, ~600 lines)
  - Medic/Core/playbook_engine.py (modified, added substitute_all and error handling)
  - Medic/requirements.txt (added cryptography)
  - tests/unit/test_secrets.py (new, 45 unit tests)
- **Learnings for future iterations:**
  - AES-GCM requires: ciphertext, 12-byte nonce, 16-byte tag (all stored separately)
  - cryptography library's AESGCM returns ciphertext+tag appended, split manually
  - Secret names must be valid identifiers (start with letter or underscore)
  - Use try/except for graceful degradation when cryptography not installed
  - Cache resolved secrets during substitution to avoid repeated DB calls
---

## 2026-02-04 01:45 CST - US-001 - Linear Issue: SRE-59
- What was implemented:
  - Created ui/ directory with Vite + React + TypeScript scaffolding
  - Installed dependencies: react 19.2.0, typescript 5.9.3, vite 7
  - Configured ESLint 9 with TypeScript, React hooks, and Prettier plugins
  - Created .prettierrc with consistent code style settings
  - Added package.json scripts: dev, build, test, lint, lint:fix, format, typecheck, preview
  - Created src/main.tsx with StrictMode React root
  - Created src/App.tsx with Medic placeholder content
  - Simplified src/index.css with basic reset styles
  - Build produces dist/ folder with production bundle
- Files changed:
  - ui/ directory (new)
  - ui/package.json, ui/package-lock.json
  - ui/eslint.config.js, ui/.prettierrc
  - ui/src/main.tsx, ui/src/App.tsx, ui/src/index.css
  - ui/vite.config.ts, ui/tsconfig.json, ui/tsconfig.app.json, ui/tsconfig.node.json
  - .gitignore (added ui/node_modules/ and ui/dist/)
- **Learnings for future iterations:**
  - Vite 7 uses new create-vite template with React 19
  - ESLint 9 uses flat config (eslint.config.js) with defineConfig()
  - Import eslint-config-prettier as prettierConfig and add to extends array
  - TypeScript check via `tsc --noEmit`, build via `tsc -b && vite build`
  - cwd is /Users/coreyjones/Documents/Github/medic/ui during npm commands
---

## 2026-02-04 02:15 CST - US-002 - Linear Issue: SRE-59
- What was implemented:
  - Created ui/Dockerfile with multi-stage build:
    - Stage 1: Node 22 Alpine builder - installs deps, runs build
    - Stage 2: nginx Alpine - copies dist/ and nginx.conf
  - Created ui/nginx.conf with:
    - Upstream proxy to medic-api:5000
    - `/` route: serve static files with SPA fallback (try_files)
    - `/api/*` route: proxy to medic-api backend
    - `/ws` route: WebSocket proxy with upgrade headers
    - Gzip compression for text assets
- Files changed:
  - ui/Dockerfile (new)
  - ui/nginx.conf (new)
- **Learnings for future iterations:**
  - Multi-stage Docker builds: use `--from=builder` to copy artifacts
  - nginx WebSocket proxy requires: proxy_http_version 1.1, Upgrade/Connection headers
  - SPA routing needs try_files $uri $uri/ /index.html for client-side routes
  - nginx upstream block defines backend service name (medic-api:5000)
---

## 2026-02-04 02:47 CST - US-003 - Linear Issue: SRE-59
- What was implemented:
  - Added medic-ui service to docker-compose.yml
  - Service builds from ui/ directory using ui/Dockerfile
  - Port 80 exposed for nginx (UI access)
  - Depends on web service (medic-api) with healthcheck condition
  - Added healthcheck for medic-ui service (curl localhost:80)
  - Created medic-network bridge network for service communication
  - Added container_name: medic-api to web service for nginx upstream reference
  - Added network alias 'medic-api' to web service for nginx.conf compatibility
  - Updated worker service MEDIC_BASE_URL to use medic-api hostname
- Files changed:
  - docker-compose.yml (modified)
- **Learnings for future iterations:**
  - Use network aliases when service name differs from hostname referenced in nginx.conf
  - docker compose config --quiet validates configuration without verbose output
  - Bridge network allows services to communicate via service/container names
  - container_name ensures consistent hostname for nginx upstream references
---
