# Ralph Progress Log
Started: Tue Feb  3 13:50:31 CST 2026

## Codebase Patterns
- Database: PostgreSQL with raw SQL (no ORM, no migration framework like Alembic)
- Tables are in the `medic` schema
- Migrations stored in `/migrations/` directory as numbered SQL files (016 is latest)
- Secrets encryption uses AES-256-GCM with key from MEDIC_SECRETS_KEY env var (base64-encoded 32-byte key)
- Use substitute_all() for variable+secret substitution in playbook steps
- All queries use parameterized queries with `%s` placeholders
- Python type checking via mypy (existing codebase has pre-existing type errors in heartbeat.py, medic.py, pagerduty_client.py)
- Unit tests in tests/unit/, run with `python3 -m pytest tests/unit/ -v`
- Pre-existing test failures in test_monitor.py due to missing `slack_client` module (not related to new code)
---

## 2026-02-03 14:15 CST - US-035
- What was implemented:
  - Created approval_requests table migration (migrations/014_create_approval_requests.sql)
  - Columns: request_id (PK), execution_id (FK unique), requested_at, expires_at, status, decided_by, decided_at
  - Status values: pending, approved, rejected, expired
  - CHECK constraint ensures decided_by/decided_at set appropriately per status
  - Indexes: execution_id, status, pending requests, expires_at, decided_by, decided_at
- Files changed:
  - migrations/014_create_approval_requests.sql (new)
- **Learnings for future iterations:**
  - Migration file numbering: check existing migrations to find next number (was 014)
  - Follow existing pattern for table/column comments
  - CHECK constraints can enforce business logic (e.g., decided_by must be set when status is approved/rejected)
  - Unique constraint on execution_id ensures one approval request per execution
---

## 2026-02-03 14:45 CST - US-036 - Linear Issue: SRE-22
- What was implemented:
  - Created Medic/Core/slack_approval.py module with:
    - ApprovalStatus enum (pending, approved, rejected, expired)
    - ApprovalRequest and ApprovalResult dataclasses
    - Database operations: create/get/update approval_requests records
    - Slack Block Kit message building with interactive buttons
    - send_approval_request(): Sends Slack message with Approve/Decline buttons
    - handle_slack_interaction(): Processes button click callbacks
    - approve_request(): Updates status to approved, resumes playbook execution
    - reject_request(): Updates status to rejected, cancels playbook execution
    - Slack signature verification for webhook security
    - expire_pending_requests(): Handles auto-expiration of timed-out requests
  - Added POST /v2/slack/interactions endpoint in routes.py
- Files changed:
  - Medic/Core/slack_approval.py (new, ~1200 lines)
  - Medic/Core/routes.py (added Slack interactions endpoint)
  - tests/unit/test_slack_approval.py (new, 42 unit tests)
- **Learnings for future iterations:**
  - Slack interactive messages use Block Kit format with specific block types (header, section, actions, context)
  - Slack webhook payloads come as form-urlencoded with a 'payload' JSON field
  - Signature verification uses HMAC-SHA256 with v0:timestamp:body format
  - For button actions, action_id identifies the action and value carries the payload (e.g., execution_id)
  - chat_update can replace interactive buttons with static result after decision
  - Import slack_approval inside route function to avoid circular imports
---

## 2026-02-03 21:00 CST - US-044
- What was implemented:
  - Created medic.secrets table migration (migrations/016_create_secrets.sql)
    - Columns: secret_id (PK), name (unique), encrypted_value (BYTEA), nonce (12 bytes), tag (16 bytes)
    - Name format constraint: [A-Za-z_][A-Za-z0-9_]*
    - Description and created_by optional columns
  - Implemented Medic/Core/secrets.py module with:
    - AES-256-GCM encryption using cryptography library
    - Key from MEDIC_SECRETS_KEY env var (base64-encoded 32-byte key)
    - generate_encryption_key() for generating new keys
    - encrypt_secret()/decrypt_secret() for AES-GCM operations
    - CRUD functions: create_secret(), get_secret(), update_secret(), delete_secret(), list_secrets()
    - get_secret_value() for decrypting at execution time
    - substitute_secrets() for ${secrets.SECRET_NAME} syntax
    - find_secret_references() and validate_secret_references() helpers
  - Updated Medic/Core/playbook_engine.py:
    - Added substitute_all() function to handle both variables and secrets
    - Updated webhook step to use substitute_all() for URL, headers, body
    - Updated script step to use substitute_all() for script content
    - Added error handling for secret substitution failures
  - Added cryptography>=42.0.0 to Medic/requirements.txt
- Files changed:
  - migrations/016_create_secrets.sql (new)
  - Medic/Core/secrets.py (new, ~600 lines)
  - Medic/Core/playbook_engine.py (modified, added substitute_all and error handling)
  - Medic/requirements.txt (added cryptography)
  - tests/unit/test_secrets.py (new, 45 unit tests)
- **Learnings for future iterations:**
  - AES-GCM requires: ciphertext, 12-byte nonce, 16-byte tag (all stored separately)
  - cryptography library's AESGCM returns ciphertext+tag appended, split manually
  - Secret names must be valid identifiers (start with letter or underscore)
  - Use try/except for graceful degradation when cryptography not installed
  - Cache resolved secrets during substitution to avoid repeated DB calls
---
